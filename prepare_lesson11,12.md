# 함수

## 함수란?

함수

- 함수는 (호출 가능한) 객체
- 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 가짐

- 일련의 과정을 문들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

- 매개변수(parameter): 입력을 전달받는 변수

- 인수(argument): 입력

- 반환값(return value): 출력



1. 함수 정의(Function Definition)

   - 함수 생성

   - 예)

     ```javascript
     function add(x, y) {
       return x + y;
     }
     ```

2. 함수 호출(Function call/invoke)

   - 함수 실행 지시 (표현식)

   - 예)

     ```javascript
     var result = add(2, 5);
     ```



## 함수의 사용 이유

여러 번 호출 가능 -> 코드의 재사용

유지보수의 편의성

코드의 신뢰성

함수의 좋은 이름 -> 코드의 가독성



## 함수 리터럴

구성

- function 키워드
- 함수 이름
  - 함수 몸체 내에서만 참조 가능한 식별자
  - 생략 가능
    - 기명 함수(함수 이름이 있는 함수)
    - 익명 함수(함수 이름이 없는 함수)
  - 식별자 네이밍 규칙 준수
- 매개변수 목록
  - 0개 이상의 매개변수를 괄호로 감싸고 쉽표로 구분
  - 인수 할당
  - 함수 몸체 내에서 변수와 동일 취급
  - 식별자 네이밍 규칙 준수
- 함수 몸체
  - 함수 호출됐을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록
  - 함수 호출에 의해 실행



## 함수 정의

함수를 정의하는 방법

1. 함수 선언문(Function Declaration/Function Statement)

   ```javascript
   function add(x, y) {
     return x + y;
   }
   ```

2. 함수 표현식(Function Expression)

   ```javascript
   var add = function (x, y) {
     return x + y;
   };
   ```

3. Function 생성자 함수(Function Constructor)

   ```javascript
   var add = new Function('x', 'y', 'return x + y');
   ```

4. 화살표 함수(Arrow Function): ES6

   ```javascript
   var add = (x, y) => x + y;
   ```



### 함수 선언문

함수 리터럴 표기법과 형태 동일

함수 이름 생략 불가능

함수를 정의하는 표현식이 아닌 문 (변수를 할당하기 전까지..)

실행되어 함수 객체를 생성

함수 이름과 동일한 이름의 식별자를 암묵적으로 선언, 생성된 함수 객체 할당



### 함수 표현식

변수 할당문의 값이 함수 리터럴인 문

함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 변수로 호출

- 자바스크립트 엔진이 (함수 선언문의 함수 이름으로) 암묵적 변수 생성
- 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체 생성
- 함수 이름은 함수 몸체 내부에서만 유효한 식별자(함수 호출 불가능)

- 함수 이름 생략하는 것이 일반적 (익명 함수)



함수는 일급 객체(first-class object)

- 함수를 값처럼 자유롭게 사용 가능
- 값처럼 변수에 할당할 수도 있고, 프로퍼티의 값이 될 수도 있고, 배열의 요소가 될 수도 있는 객체

- 함수 리터럴로 생성한 함수 객체를 변수에 할당해 함수 정의



### 함수 생성 시점과 함수 호이스팅

함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점 다름

- 함수 선언문으로 정의한 함수
  - 함수 선언문 이전 참조 또는 호출 가능
  - 코드가 순차적으로 실행되기 이전 자바스크립트 엔진에 의해 먼저 실행
  - 다른 코드가 실행되기 이전 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 함수 객체 생성해 할당
  - 함수 호이스팅
    - 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작
    - 선언 단계와 초기화 단계, 할당 단계까지 동시에 진행

- 함수 표현식으로 정의한 함수
  - 함수 표현식 이전 참조 또는 호출 불가능
  - 변수 선언문과 변수 할당문을 한번에 기술한 축약 표현과 동일하게 동작
  - 변수 할당문의 값은 런타임에 평가
  - 함수 표현식의 함수 리터럴도 런타임에 평가



### Function 생성자 함수

자바스크립트가 기본 제공하는 빌트인 함수

매개변수 목록과 함수 몸체를 문자열로 전달받음

new 연산자와 함께 호출하며 생성된 함수 객체를 반환

생성자 함수(Constructor Function): 객체를 생성하는 함수

함수 선언문, 함수 표현식으로 생성한 함수와 다르게 동작

클로저를 생성하지 않음



> Function 생성자 함수로 생성한 함수는 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다. Function 생성자 함수 방식으로 생성한 함수는 클로저를 생성하지 않는다.



### 화살표 함수

function 키워드 대신 화살표(=>, Fat arrow) 사용

항상 익명 함수로 정의

기존 함수와 this 바인딩 방식이 다름

prototype 프로퍼티 없음

arguments 객체 생성하지 않음



## 함수 호출

함수는 함수를 참조하는 변수와 한 쌍의 소괄호인 함수 호출 연산자로 호출

함수 호출 연산자 내에는 0개 이상의 인수(매개변수에 할당할 수 있는 값)를 쉼표로 구분해 나열



1. 함수 호출

2. 현재 실행 흐름 중단하고 호출된 함수로 컨트롤 넘김

3. 매개변수에 인수 할당되고 함수 몸체의 문들이 실행



## 매개변수와 인수

함수의 실행을 위해 함수 외부에서 함수 내부로 값을 전달할 필요가 있을 때

- 매개변수(인자)를 통해 인수를 전달

- 함수 몸체 내에서 암묵적으로 매개변수 생성되고, undefined로 초기화된 이후 인수가 할당

- 함수는 매개변수와 인수의 개수 체크하지 x

  - 인수가 부족한 경우, 매개변수의 값은 undefined

  - 인수가 초과한 경우, 초과되는 인수 무시



매개변수

- 함수를 정의할 때 선언
- 함수 몸체 내부에서 변수와 동일 취급
- 함수 몸체 내부에서만 참조 가능(함수 몸체 외부에서는 참조 불가능)
- 매개변수의 스코프(유효 범위)는 함수 내부

인수

- 함추를 호출할 때 지정
- 개수와 타입에 제한 x



arguments 객체: 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관



## 인수 확인

자바스크립트 함수

1. 매개변수와 인수의 개수가 일치하는지 확인하지 x
2. 매개변수의 타입을 사전에 지정하지 x



## 매개변수의 개수

매개변수의 최대 개수 제한이 정해져 있지 x

매개변수는 순서에 의미

- 매개변수가 많아지면 함수 호출할 때 전달해야 할 인수의 순서 고려해야

- 개수는 0개이며 적을 수록 좋음 (최대 3개 이상 넘지 않는 것을 권장)
- 3개 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받는 것이 유리



> 객체를 인수로 사용하는 경우, 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경쓰지 않아도 된다. 하지만 주의할 것은 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부작용이 발생한다는 것이다.



## 외부 상태의 변경과 함수형 프로그래밍

매개변수

- 함수 몸체 내부에서 변수와 동일하게 취급
- 타입에 따라 값에 의한 전달,  참조에 의한 전달 방식 그대로 따름



원시 타입 인수

- 값 자체가 복사되어 매개변수에 전달
- 함수 몸체에서 그 값을 변경해도 원본 훼손되지 않음
- 함수 외부에서 함수 몸체 내부로 전달한 원시값의 원본을 변경하는 어떠한 부수 효과(side-effect)도 발생하지 않음

객체 타입 인수

- 참조값이 복사되어 매개변수에 전달
- 함수 몸체에서 참조값으로 참조한 객체를 변경할 경우 원본 훼손
- 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원본 객체가 변경되는 부수 효과 발생



의도치 않은 객체의 변경을 추적하는 문제의 해결 방법

- 객체를 불변 객체(immutable object)로 만들어 사용
- 객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만듦
- 객체의 상태 변경이 필요한 경우 깊은 복사를 통해 새로운 객체 생성 후 변경
- 외부 상태가 변경되는 부수 효과 없앰



함수형 프로그래밍

- 순수 함수(Pure function): 어떤 외부 상태도 변경시키지 않는(부수 효과가 없는) 함수
- 비순수 함수(Impure function): 외부 상태를 변경시키는(부수 효과가 있는) 함수

- 변수 사용을 억제해 상태 변경을 피하고 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하려는 프로그래밍 패러다임
- 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력



## 반환문

return 키워드 사용해 실행 결과 반환

반환문 생략 가능 (암묵적으로 undefined 반환)

예)

```javascript
return x * y;
```



역할

1. 함수의 실행 중단하고 함수 몸체를 빠져나감

   반환문 이후 다른 문 존재하면 그 문은 실행되지 않고 무시

   ```javascript
   function multiply(x, y) {
     return x * y;
     console.log('실행되지 않는다.');
   }
   
   console.log(multiply(3, 5));
   ```

2. return 키워드 뒤에 지정한 값 반환

   반환값을 명시적으로 지정하지 않으면 undefined 반환

   ```javascript
   function foo () {
     return;
   }
   
   console.log(foo());
   ```



## 다양한 함수의 형태

### 즉시실행함수

IIFE, Immediately Invoke Function Expression

함수의 정의와 동시에 즉시 호출되는 함수

한번만 호출되며 다시 호출 불가능

함수 이름이 없는 익명 즉시 실행 함수 사용이 일반적

- 함수 이름이 있어도 함수 몸체에서만 참조할 수 있는 식별자므로 즉시 실행 함수 다시 호출 불가능

반드시 그룹 연산자 (...)로 감쌈

- 그룹 연산자로 먼저 함수를 평가하여 함수 객체 생성한 다음 함수 호출

- 함수 선언문이나 함수 표현식을 그룹 연산자로 감싸면 함수가 평가되어 함수 객체가 됨

일반 함수처럼 값 반환과 인수 전달 가능

- 예

  ```javascript
  res = (function (a, b) {
    return a * b;
  }(3, 5));
  
  console.log(res);
  ```

변수나 함수 이름이 충돌하는 것을 방지



예

```javascript
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());
```



### 재귀 함수

recursive call

함수가 자기 자신을 호출하는 함수

반복 연산 간단하게 구현 예)팩토리얼

- 예

  ```javascript
  function factorial(n) {
    if (n <= 1) return 1;
    return factorial(n - 1) * n;
  }
  ```

자신을 무한히 연쇄 호출하므로 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 함

- 탈출 조건이 없는 경우 stack overflow 에러

대부분 for 문이나 while 문으로 구현 가능

- 예

  ```javascript
  function factorial(n) {
    if (n <= 1) return 1;
  
    var res = n;
    while (--n) res *= n;
    return res;
  }
  ```

  

### 중첩 함수

중첩 함수(nested function) 또는 내부 함수(Inner function)

함수 내부에 정의된 함수

일반적으로 자신을 포함하는 외부 함수를 돕는 헬퍼 함수 역할

중첩 함수는 외부 함수의 변수에 접근 가능하지만, 외부 함수는 중첩 함수의 변수에 접근 불가능

스코프와 관련



### 콜백 함수

자바스크립트의 함수는 일급 객체므로 함수의 매개 변수에게 함수 전달 가능

함수 호출 시 함수에 인수로 전달된 함수

함수에 전달돼 헬퍼 함수의 역할

함수 외부에서 인수로 주입하기 때문에 자유롭게 교체 가능

비동기 처리를 위해 사용하는 일반적인 패턴

- 주로 이벤트 처리나 Ajax 통신에 사용

- 예

  ```javascript
  document.getElementById('myButton').addEventListener('click', function () {
    console.log('button clicked!');
  });
  
  setTimeout(function () {
    console.log('1초 경과');
  }, 1000);
  ```

  

고차 함수에서도 사용하는 패턴

- 예

  ```javascript
  var res = [1, 2, 3].map(function (item) {
    return item * 2;
  });
  
  console.log(res);
  
  
  res = [1, 2, 3].filter(function (item) {
    return item % 2;
  });
  
  console.log(res); 
  ```

  

예

```javascript
function print(f) {
  var string = 'Hello';
  return f(string);
}

var res1 = print(function (str) {
  return str.toUpperCase();
});

var res2 = print(function (str) {
  return str.toLowerCase();
});

console.log(res1, res2);
```



> 콜백 함수가 콜백 함수를 전달받는 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 인수로 곧바로 전달하는 것이 일반적이다. 이때 콜백 함수로서 전달된 함수 리터럴은 콜백 함수를 전달받은 함수가 호출될 때 평가되어 생성된다.

> 단, 콜백 함수를 다른 곳에서도 호출할 필요가 있거나, 콜백 함수를 전달받는 함수가 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 콜백 함수를 전달하는 편이 효율적이다.