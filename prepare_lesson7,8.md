# 제어문

일반적으로 코드는 위에서 아래 방향 순차적으로 실행

제어문 사용하면 코드의 실행 흐름 인위적으로 제어 가능



## 블록문

0개 이상의 문을 중괄호로 묶은 것

하나의 실행 단위로 취급

일반적으로 제어문, 함수 선언문 등에서 사용

블록문 끝에는 ; 붙이지 않음

 

## 조건문

주어진 조건식의 평가 결과에 따라 블록문 실행 결정

조건식: 불리언 값으로 평가될 수 있는 표현식



### if...else 문

if (조건식1) {

​	<!--코드 블록: 조건식1 참이면 실행-->

} else if (조건식2) {

​	<!--코드 블록: 조건식2 참이면 실행-->

} else {

​	<!--코드 블록: 조건식1, 조건식2 모두 거짓이면 실행-->

}



if...else 문

- 표현식이 아닌 문

- 값처럼 사용할 수 없기 때문에 변수에 할당 불가능

- 코드 블록 내 문이 하나이면 중괄호 생략 가능

- if (num > 0) {

  kind = '양수';

  } else if (num < 0) {

  kind = '음수';

  } else {

  kind = '영';

  }

삼항 조건 연산자

- 값으로 평가되는 표현식을 만듦
- 값처럼 사용할 수 있기 때문에 변수에 할당 가능
- var kind = num ? (num > 0 ? '양수' : '음수') : '영';



> 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 하지만 if…else 문은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다는 차이가 있다.



### switch 문

switch (표현식) {

​	case 표현식1:

​		switch 문 표현식과 표현식1이 일치하면 실행될 문;

​		break;

​	case 표현식2:

​		switch 문 표현식과 표현식2가 일치하면 실행될 문;

​		break;

​	default:

​		switch 문 표현식과 일치하는 표현식 없을 때 실행될 문; 

}



표현식: 불리언 값보다 문자열, 숫자 값인 경우가 많음

-> 논리적 참, 거짓보다 다양한 상황(case)에 따라 실행할 코드 블록 결정

폴스루(fall through): 문 실행한 후 문을 탈출하지 않고 switch 문이 끝날 때까지 이후의 모든 case 문 실행

break 문: 코드 블록에서 탈출. 폴스루가 발생하지 않는 이유



## 반복문

주어진 조건식의 평가 결가가 참인 경우 코드 블럭 실행

조건식이 거짓일 때까지 반복



### for 문

for (변수 선언문 또는 할당문; 조건식; 증감식) {

​	조건식 참인 경우 반복 실행될 문;

}



### while 문

조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환

조건식의 평가 결과가 언제나 참이면 무한루프



while (true) {

​	console.log(count);

​	count++;

​	if (count === 3) break;

}



### do...while 문

코드 블록 먼저 실행하고 조건식 평가

코드 블록 무조건 한 번 이상 실행



do {

​	console.log(count);

​	count++;

} while (count < 3);



## break 문

레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출



레이블 문

- 식별자가 붙은 문
- 프로그램의 실행 순서를 제어하기 위해 사용
- 탈출하려면 break 문에 레이블 식별자 지정
- 중첩된 for 문을 외부로 탈출할 때



> 중첩된 for 문의 내부 for 문에서 break 문을 실행하면 내부 for 문을 탈출하여 외부 for 문으로 진입한다. 이때 내부 for 문이 아닌 외부 for 문을 탈출하려면 레이블 문을 사용한다.



반복문, switch 문

- break 문에 레이블 식별자 지정 x
- 반복문을 더이상 진행하지 않아도 될 때



> 문자열은 유사배열이므로 for 문으로 순회할 수 있다.

> String.prototype.indexOf 메소드



## continue 문

반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동

반복문을 탈출하지는 않음

if 문 내에서 실행할 코드가 길 때 가독성 높임 (if 문 밖에 코드 작성 가능)



if 문

- if (string[i] === search) {

  ​	count++;

  ​	...

  }

continue 문

- if (string[i] !== search) continue;

  count++;

  ...



> String.prototype.match 메소드





# 타입 변환과 단축 평가

## 타입 변환이란?

명시적 타입 변환(타입 캐스팅): 개발자가 의도적으로 값의 타입 변환

암묵적 타입 변환(타입 강제 변환): 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암무적으로 타입 자동 변환



## 암묵적 타입 변환

### 문자열 타입으로 변환

'+' -> 피연산자 중 하나 이상 문자열이면 문자열 연결 연산자로 동작



### 숫자 타입으로 변환

'-', '*' -> 산술 연산자로 동작

'>' -> 피연산자의 크기를 비교하므로 표현식을 평가하기 위해 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환

'+' -> 단항 연산자의 경우 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환



' ', [ ], null, false -> 0으로 변환

true -> 1로 변환

객체, 빈 배열이 아닌 배열, undefined -> NaN(숫자로 변환되지 x)



### 불리언 타입으로 변환

if 문, for 문과 같은 제어문, 삼항 조건 연산자의 조건식 평가 결과를 암묵적 타입 변환



불리언 타입이 아닌 값을 Truthy 값 또는 Falsy 값으로 구분

- Truthy 값 -> true로 변환

- Falsy 값 -> false로 변환 예) false, undefined, null, 0, -0, NaN, ' '



함수

- 어떤 작업을 수행하기 위해 필요한 문들의 집합을 정의한 코드 블록
- 이름과 매개변수를 가짐
- 필요할 때 호출하여 일괄적으로 실행 가능



## 명시적 타입 변환

1. 래퍼 객체 생성하기 위해 사용하는 표준 빌트인 생성자 함수(문자열, 숫자, 불리언)를 new 연산자 없이 호출
2. 빌트인 메소드 사용
3. 암묵적 타입 변환 이용



래퍼 객체: 원시값을 감싸는 객체(원시값을 객체처럼 사용)



### 문자열 타입으로 변환

1. String 생성자 함수를 new 연산자 없이 호출

   - String(1)
   - String(NaN)
   - String(true)

2. Object.prototype.toString 메소드 사용

   - (1).toString()
   - (NaN).toString()
   - (true).toString()

3. 문자열 연결 연산자 이용

   - 1 + ''

   - NaN + ''

   - true + ''

     

### 숫자 타입으로 변환

1. Number 생성자 함수를 new 연산자 없이 호출
   - Number('-1')
   - Number('10.53')
   - Number(true)
2. parseInt, parseFloat 함수 사용 (문자열만 변환 가능)
   - parseInt('-1')
   - parseFloat('10.53')
3. '+' 단항 연결 연산자 이용
   - +'-1'
   - +'10.53'
   - +true
4. '*' 산술 연산자 이용
   - '-1' * 1
   - '10.53' * 1
   - true * 1



### 불리언 타입으로 변환

1. Boolean 생성자 함수를 new 연산자 없이 호출
   - Boolean('x') -> true
   - Boolean('') -> false
   - Boolean('false') -> true
   - Boolean(1) -> true
   - Boolean(NaN) -> false
   - Boolean(Infinity) -> true
   - Boolean(null) -> false
   - Boolean(undefined) -> false
   - Boolean([]) -> true
2. ! 부정 논리 연산자 두 번 사용
   - !! 'x'
   - !! ''
   - !! 'false'
   - !! 1
   - !! NaN
   - !! Infinity
   - !! null
   - !! undefined
   - !! []



> 빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다. 

> console.log(Boolean([]));        // true



## 단축 평가

논리 평가를 결정한 피연산자를 그대로 반환

- 객체가 null인지 확인하고 프로퍼티 참조할 때

- 함수 매개변수에 기본값 설정할 때



||(논리합) 연산자와 &&(논리곱) 연산자

- true || anything -> 평가 결과 true

- false || anything -> 평가 결과 anything

- true && anything -> 평가 결과 anything

- false && anything -> 평가 결과 false