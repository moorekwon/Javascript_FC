# 객체 리터럴

## 객체란?

원시 타입을 제외한 나머지 값들(함수, 배열, 정규표현식 등)



원시 타입

- 단 하나의 값만 나타냄
- 원시 값(원시 타입의 값)은 변경 불가능한 값(immutable value)

객체 타입(object / reference type)

- 다양한 타입의 값들을 하나의 단위로 구성한 복합적인 자료 구조
- 객체(객체 타입의 값)는 변경 가능한 값(mutable value)



자바스크립트의 객체

- 키(key)와 값(value)으로 구성된 프로퍼티(Property)들의 집합
- 함수와 밀접한 관계 (자바스크립트의 함수는 일급 객체, First-class object)



객체: 프로퍼티와 메소드로 구성된 집합체

- 프로퍼티
  - 객체의 상태를 나타내는 값(data)
  - 키(key)와 값(value)으로 구성
- 메소드
  - 프로퍼티를 참조하고 조작할 수 있는 동작(behavior)
  - 객체에 제한되어 있는 함수
  - 프로퍼티 값이 함수일 경우 일반 함수와 구분하여 부름



## 객체 리터럴에 의한 객체 생성

클래스 기반 객체지향 언어

- C++, Java, 등
- 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자(constructor) 호출, 인스턴스 생성
- 인스턴스(instance): 클래스에 의해 생성되어 메모리에 저장된 실체(실제로 존재하는 것)

프로토타입 기반 객체지향 언어

- 자바스크립트
- 다양한 객체 생성 방법 존재
  - 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메소드, 클래스(ES6)
  - 객체 리터럴 이외의 객체 생성 방식은 모두 함수 사용



리터럴 표기법(Literal notation): 값을 생성하는 가장 기본적인 방법

객체 리터럴

- 중괄호({...}) 내에 0개 이상의 프로퍼티 정의
- 변수에 할당 이루어지는 시점에 객체 리터럴 해석되고 그 결과 객체 생성
- 중괄호 내에 프로퍼티 정의하지 않으면 빈 객체 생성
- 표현식 => 닫는 중괄호 뒤에 세미 콜론(;) 붙임
- 객체 리터럴에 프로퍼티 포함시켜 객체 생성과 동시에 프로퍼티 생성 가능
- 객체 생성 이후 프로퍼티 동적 추가 가능



## 프로퍼티

객체: 프로퍼티(Property)들의 집합

프로퍼티

- 키(key)와 값(value)으로 구성
- 쉼표(,)로 구분하여 나열
- 프로퍼티 키(key)
  - 빈 문자열 포함 모든 문자열 또는 symbol 값
  - 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표 사용
  - 문자열이나 symbol 값 이외의 값을 사용 -> 암묵적 타입 변환을 통해 문자열로 변환
  - 숫자 리터럴 사용 -> 내부적으로 문자열로 변환
  - 이미 존재하는 프로퍼티 키 중복 선언 -> 나중에 선언한 프로퍼티가 덮어씀
- 프로퍼티 값(value)
  - 자바스크립트에서 사용가능한 모든 값
- 계산된 프로퍼티 이름: 문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 때, 프로퍼티 키로 사용할 표현식을 대괄호([...])로 묶음



## 메소드

함수: 값으로 취급할 수 있으며, 프로퍼티의 값이 될 수 있음

메소드: 프로퍼티 값이 (객체에 제한되어 있는) 함수일 경우

메소드 내부에서 사용한 this 키워드: 객체 자신을 가리키는 참조변수



## 프로퍼티 접근

프로퍼티 값에 접근하는 방법

- 마침표 표기법(Dot notation)

  - 객체로 평가할 수 있는 표현식.프로퍼티 키

  - 프로퍼티 키: 식별자 네이밍 규칙을 준수한 이름

- 대괄호 표기법(Bracket notation)

  - 객체로 평가할 수 있는 표현식[프로퍼티 키]

  - 프로퍼티 키: 따옴표로 감싼 문자열



## 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값 할당



## 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값 할당



## 프로퍼티 삭제

delete 연산자

- 객체의 프로퍼티 삭제
- 피연산자는 프로퍼티 값에 접근 가능한 표현식
- 존재하지 않는 프로퍼티 삭제 -> 에러없이 무시



## ES6에서 추가된 객체 리터럴의 확장 기능

### 프로퍼티 축약 표현

프로퍼티 값으로 변수 사용

변수 이름과 프로퍼티 키가 동일한 이름

예)

```javascript
let x = 1, y = 2;

const obj = { x, y };

console.log(obj);
```



### 프로퍼티 키 동적 생성

문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식 사용

계산된 프로퍼티 이름: 프로퍼티 키로 사용할 표현식을 대괄호([...])로 묶음(ES5)

예)

```javascript
var prefix = 'prop';
var i = 0;

var obj = {};

obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;

console.log(obj);
```



객체 리터럴 내부에서도 프로퍼티 키 동적 생성 가능(ES6)

예)

```javascript
const prefix = 'prop';
let i = 0;

var obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i
};

console.log(obj);
```



### 메소드 축약 표현

function 키워드를 생략한 축약 표현 사용 가능(ES6)

프로퍼티에 할당한 함수와 다르게 동작

예)

```javascript
const obj = {
  name: 'Lee',
  sayHi() {
    console.log('Hi! ' + this.name);
  }
};

obj.sayHi();
```





# 원시 값과 객체의 비교

## 원시 값

### 변경 불가능한 값

원시 타입(primitive type)의 값

- 변경 불가능한 값(immutable value)
- 한번 생성된 원시 값은 read-only한 값
- 불변성(immutability): 원시 값 자체를 수정하는 것이 아니라 새로운 메모리 공간을 확보해 값 재할당
- 데이터의 신뢰성 보장
- 값을 변경할 수 없다 ≠ 재할당 할 수 없다



변수

- 새로운 값 재할당으로 변수값 변경 가능



상수

- 재할당이 금지된 변수로 단 한번만 할당 허용
- 상수 ≠ 변경 불가능한 값



> // 하지만 const 키워드를 사용해 선언한 상수에 할당된 객체는 변경할 수 있다.
> // 즉, 상수는 재할당이 금지된 변수일 뿐이다.



### 문자열과 불변성

원시 값인 문자열 vs 다른 원시 값

문자열

- 0개 이상인 문자(character)들의 집합
- 1개의 문자는 2byte 메모리 공간에 저장
- C는 문자들의 배열, Java는 String 객체로 처리
- 유사 배열 객체 (하지만 원시 타입인 값..)



유사 배열 객체(Array-like Object)

- 마치 배열처럼 인덱스로 프로퍼티 값에 접근 가능
- length 프로퍼티를 갖는 객체
- for  문으로 순회 가능
- 원시 값을 객체처럼 사용하면 원시 값을 감싸는 레퍼 객체로 자동 변환



### 값에 의한 전달

값에 의한 전달(Pass by value)

- 변수에 (원시값을 갖는) 변수를 할당했을 때, 그 원시값이 복사되어 전달
- 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값
- 두 변수의 원시값은 서로 간섭할 수 없음



## 객체

- 프로퍼티의 개수가 정해져 있지 않음

- 동적으로 추가 및 삭제 가능
- 프로퍼티 값에 제약 없음
- 원시 값처럼 확보해야 할 메모리 공간의 크기를 사전에 정할 수 없음 (원시 값과 다른 방식으로 동작)



자바스크립트의 객체 관리 방식

- 클래스 없이 객체 생성 가능
- 객체 생성된 이후에도 동적으로 프로퍼티와 메소드 추가 가능
- 대부분의 모던 자바스크립트 엔진은 해시 함수 기반의 유사 딕셔너리 구조 사용



> 이러한 이유로 대부분의 모던 자바스크립트 엔진은 객체의 프로퍼티 값의 위치를 메모리에 저장하기 위해 해시 함수 기반의 유사 딕셔너리 구조(dictionary-like structure)를 사용한다.



### 변경 가능한 값

- 객체는 변경 가능한 값(mutable value)

- 객체를 할당한 변수는 참조 값(Reference value)을 값으로 가짐
  - 참조 값: 생성된 객체가 실제로 저장된 메모리 공간의 주소 값

- 객체를 할당한 변수를 평가하면 그 변수에 저장된 참조 값으로 실제 객체에 접근해 그 객체를 반환
- 메모리에 저장된 객체를 직접 수정 가능 (참조 값은 변경되지 x)
- 얕은 복사(shallow copy) / 깊은 복사(deep copy)



### 참조에 의한 전달

참조에 의한 전달(Pass by reference)

- 객체를 가리키는 변수(원본)를 다른 변수(복사본)에 할당했을 때, 원본의 참조 값이 복사되어 전달
- 원본과 사본은 같은 참조 값을 가짐 (동일한 객체를 가리킴)
- 여러 개 식별자가 하나의 객체 공유 가능
- 원본, 사본 어떤 한쪽에서 객체를 변경하면 서로 영향을 주고 받음