# 객체 리터럴

## 객체란?

원시 타입을 제외한 나머지 값들(함수, 배열, 정규표현식 등)



원시 타입

- 단 하나의 값만 나타냄
- 원시 값(원시 타입의 값)은 변경 불가능한 값(immutable value)

객체 타입(object / reference type)

- 다양한 타입의 값들을 하나의 단위로 구성한 복합적인 자료 구조
- 객체(객체 타입의 값)는 변경 가능한 값(mutable value)



자바스크립트의 객체

- 키(key)와 값(value)으로 구성된 프로퍼티(Property)들의 집합
- 함수와 밀접한 관계 (자바스크립트의 함수는 일급 객체, First-class object)



객체: 프로퍼티와 메소드로 구성된 집합체

- 프로퍼티
  - 객체의 상태를 나타내는 값(data)
  - 키(key)와 값(value)으로 구성
- 메소드
  - 프로퍼티를 참조하고 조작할 수 있는 동작(behavior)
  - 객체에 제한되어 있는 함수
  - 프로퍼티 값이 함수일 경우 일반 함수와 구분하여 부름



## 객체 리터럴에 의한 객체 생성

클래스 기반 객체지향 언어

- C++, Java, 등
- 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자(constructor) 호출, 인스턴스 생성
- 인스턴스(instance): 클래스에 의해 생성되어 메모리에 저장된 실체(실제로 존재하는 것)

프로토타입 기반 객체지향 언어

- 자바스크립트
- 다양한 객체 생성 방법 존재
  - 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메소드, 클래스(ES6)
  - 객체 리터럴 이외의 객체 생성 방식은 모두 함수 사용



리터럴 표기법(Literal notation): 값을 생성하는 가장 기본적인 방법

객체 리터럴

- 중괄호({...}) 내에 0개 이상의 프로퍼티 정의
- 변수에 할당 이루어지는 시점에 객체 리터럴 해석되고 그 결과 객체 생성
- 중괄호 내에 프로퍼티 정의하지 않으면 빈 객체 생성
- 표현식 => 닫는 중괄호 뒤에 세미 콜론(;) 붙임
- 객체 리터럴에 프로퍼티 포함시켜 객체 생성과 동시에 프로퍼티 생성 가능
- 객체 생성 이후 프로퍼티 동적 추가 가능



## 프로퍼티

객체: 프로퍼티(Property)들의 집합

프로퍼티

- 키(key)와 값(value)으로 구성
- 쉼표(,)로 구분하여 나열
- 프로퍼티 키(key)
  - 빈 문자열 포함 모든 문자열 또는 symbol 값
  - 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표 사용
  - 문자열이나 symbol 값 이외의 값을 사용 -> 암묵적 타입 변환을 통해 문자열로 변환
  - 숫자 리터럴 사용 -> 내부적으로 문자열로 변환
  - 이미 존재하는 프로퍼티 키 중복 선언 -> 나중에 선언한 프로퍼티가 덮어씀
- 프로퍼티 값(value)
  - 자바스크립트에서 사용가능한 모든 값
- 계산된 프로퍼티 이름: 문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 때, 프로퍼티 키로 사용할 표현식을 대괄호([...])로 묶음



## 메소드

함수: 값으로 취급할 수 있으며, 프로퍼티의 값이 될 수 있음

메소드: 프로퍼티 값이 (객체에 제한되어 있는) 함수일 경우

메소드 내부에서 사용한 this 키워드: 객체 자신을 가리키는 참조변수



## 프로퍼티 접근

프로퍼티 값에 접근하는 방법

- 마침표 표기법(Dot notation)

  - 객체로 평가할 수 있는 표현식.프로퍼티 키

  - 프로퍼티 키: 식별자 네이밍 규칙을 준수한 이름

- 대괄호 표기법(Bracket notation)

  - 객체로 평가할 수 있는 표현식[프로퍼티 키]

  - 프로퍼티 키: 따옴표로 감싼 문자열



## 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값 할당



## 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값 할당



## 프로퍼티 삭제

delete 연산자

- 객체의 프로퍼티 삭제
- 피연산자는 프로퍼티 값에 접근 가능한 표현식
- 존재하지 않는 프로퍼티 삭제 -> 에러없이 무시



## ES6에서 추가된 객체 리터럴의 확장 기능

### 프로퍼티 축약 표현

프로퍼티 값으로 변수 사용

변수 이름과 프로퍼티 키가 동일한 이름

예)

```javascript
let x = 1, y = 2;

const obj = { x, y };

console.log(obj);
```



### 프로퍼티 키 동적 생성

문자열 또는 문자열로 변환 가능한 값을 반환하는 표현식 사용

계산된 프로퍼티 이름: 프로퍼티 키로 사용할 표현식을 대괄호([...])로 묶음(ES5)

예)

```javascript
var prefix = 'prop';
var i = 0;

var obj = {};

obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;

console.log(obj);
```



객체 리터럴 내부에서도 프로퍼티 키 동적 생성 가능(ES6)

예)

```javascript
const prefix = 'prop';
let i = 0;

var obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i
};

console.log(obj);
```



### 메소드 축약 표현

function 키워드를 생략한 축약 표현 사용 가능(ES6)

프로퍼티에 할당한 함수와 다르게 동작

예)

```javascript
const obj = {
  name: 'Lee',
  sayHi() {
    console.log('Hi! ' + this.name);
  }
};

obj.sayHi();
```