# 전역 변수의 문제점

## 변수의 생명 주기

### 지역 변수의 생명 주기

변수는 자신이 선언된 위치에서 생성되고 소멸

함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸

함수 내부에서 선언된 지역 변수는 함수가 호출되어 실행되는 동안에만 유효

지역 변수의 생명 주기 = 함수의 생명 주기



전역 변수 선언

- 다른 코드가 실행되기 이전에 어디에 있던지 상관없이 가장 먼저 실행

- 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행



지역 변수 선언

1. 함수 호출
   - 변수 선언문이 자바스크립트 엔진에 의해 가장 먼저 실행되어 변수 선언
   - undefined로 초기화

2. 함수 몸체의 문들이 순차적으로 실행
3. 변수 할당문 실행
   - 변수에 값 할당

4. 함수 종료
   - 변수도 소멸
   - 생명 주기 종료



변수 호이스팅

- 스코프를 단위로 동작
- 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작
- 지역 변수는 함수 전체에서 유효 (변수 할당문 실행 이전까지는 undefined 값 가짐)



### 전역 변수의 생명 주기

전역 코드

- 명확한 호출없이 실행
- 전역 코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행
- return 문 사용 불가능
- 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료

함수

- 함수 몸체의 마지막 문 또는 return 문 실행되면 종료
- return 문은 함수 몸체 내부에서만 사용 가능 (Node.js 환경에서는 파일의 가장 바깥 영역에 사용해도 에러 발생 x)



var 키워드로 선언한 전역 변수

- 전역 객체의 프로퍼티가 됨
- 브라우저 환경에서 전역 객체는 window
- window는 웹페이지가 종료하기 전까지 유효
- var 키워드로 선언한 전역 변수는 웹페이지를 종료할 때까지 유효



## 전역 변수의 문제점

암묵적 결합

- 전역 변수를 사용하는 의도: 코드 어디에서든지 전역 변수를 사용하겠다!
- 모든 코드가 전역 변수를 참조, 변경할 수 있도록 허용
- 변수의 유효 범위가 클수록 코드의 가독성 나빠지고, 의도치 않게 상태 변경될 수 있는 위험성 높음

긴 생명 주기

- 생명 주기가 길고, 상태를 변경할 기회가 많고, 메모리 리소스를 오랜 기간 소비
- var 키워드는 변수의 중복 선언이 허용되기 때문에 의도치 않은 재할당 가능성

스코프 체인 상에서 종점에 존재

- 변수를 검색할 때 전역 변수가 가장 마지막에 검색됨
- 검색 속도가 가장 느림

네임 스페이스 오염

- 파일이 분리돼 있다해도 하나의 전역 스코프를 공유
- 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 문제



## 전역 변수 사용 억제 방법

### 즉시 실행 함수

함수의 정의와 동시에 호출되는 즉시 단 한번만 호출

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨

전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용

예)

```javascript
(function () {
  var foo = 10;
  // ...
}());

console.log(foo); 
```



### 네임 스페이스 객체

네임 스페이스 역할 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

식별자 충돌 방지 (네임 스페이스를 분리)

네임 스페이스 객체 자체가 전역 변수에 할당 (유용해 보이진 않음)

예)

```javascript
var MYAPP = {};

MYAPP.name = 'Lee';

console.log(MYAPP.name); 
```



네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가해 계층적으로 구성 가능

예)

```javascript
var MYAPP = {};

MYAPP.person = {
  name: 'Lee',
  address: 'Seoul'
};

console.log(MYAPP.person.name); 
```



### 모듈 패턴

관련이 있는 변수, 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만듦

자바스크립트의 클로저 기능을 기반으로 동작

캡슐화 구현 가능

- 캡슐화: 외부에 공개될 필요 없는 정보를 숨기는 것
- 정보 은닉(information hiding)
- 자바스크립트는 public, private, protected 등 접근 제한자 제공하지 않음

전역 네임 스페이스의 오염을 막음

즉시 실행 함수가 객체를 반환하고, 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환

- 퍼블릭 멤버(public member): 반환되는 객체의 프로퍼티는 외부에 노출
- 프라이빗 멤버(private member): 외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근 불가능

예)

```javascript
var Counter = (function () {
  var num = 0;

  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

console.log(Counter.num);

console.log(Counter.increase());
console.log(Counter.increase());
console.log(Counter.decrease()); 
console.log(Counter.decrease()); 
```



### ES6 모듈

2019년 1월 기준, 대부분의 브라우저가 완전히 지원하지 않음

SystemJS, RequireJS 등 모듈 로더 또는 Webpack 등 모듈 번들러 사용해야 함





# let, const와 블록 레벨 스코프

## var 키워드로 선언한 변수의 문제점

### 변수 중복 선언 허용

같은 스코프 내에서 변수 중복 선언하면 나중에 작성된 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작

에러 발생하지 않음



### 함수 레벨 스코프

오로지 함수의 코드 블록만 지역 스코프로 인정

함수 외부에서 선언한 변수는 모두 전역 변수

전역 변수 남발할 가능성



### 변수 호이스팅

변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작

변수 선언문 이전에 변수 참조 가능 (스코프에 변수가 존재)

할당문 이전에 변수 참조하면 undefined 반환 (할당문에 도달하면 비로소 값이 할당)

에러 발생하지 않으나, 가독성 떨어뜨리고 오류 발생시킬 여지가 있음



런타임 이전에 암묵적으로 "선언 단계"와 "초기화 단계"가 한번에 진행

- 선언 단계
  - 스코프(실행 컨텍스트의 렉시컬 환경)에 변수 식별자 등록
  - 자바스크립트 엔진에 변수의 존재를 알림
- 초기화 단계
  - 즉시 undefined로 변수를 초기화



## let 키워드

var 키워드의 단점 보완하기 위해 ES6에서 도입

var 키워드와 동일하게 변수를 선언할 때 사용

재할당이 자유로움



### 변수 중복 선언 금지

동일한 이름은 갖는 변수를 중복 선언하면 문법 에러 발생



### 블록 레벨 스코프

모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등)을 지역 스코프로 인정

함수 내의 코드 블록

- 함수 레벨 스코프에 중첩
- 함수도 코드 블록이므로 스코프를 만듦



### 변수 호이스팅

변수 호이스팅이 발생하지 않는 것처럼 동작 (하지만 그렇지 않음)

변수 선언문 이전에 참조하면 참조 에러 발생



일시적 사각지대(Temporal Dead Zone; TDZ)

- 스코프의 시작 지점부터 초기화 시작 지점까지의 구간

- 스코프의 시작 지점부터 초기화 시작 지점(변수 선언문)까지 변수 참조 불가능



"선언 단계"와 "초기화 단계"가 분리되어 진행

- 선언 단계
  - 런타임 이전에 암묵적으로 먼저 실행
- 초기화 단계
  - 변수 선언문에 도달했을 때 실행



### 전역 객체와 let

전역 객체(Global Object)

- 어떤 객체보다도 먼저 생성되어 어떤 객체에도 속하지 않은 최상위 객체

- 브라우저 환경 - window 객체

- Node.js 환경 - global 객체

- 전역 객체의 프로퍼티

  - var 키워드로 선언한 전역 변수, 암묵적 전역 변수, 전역 함수
    - 암묵적 전역 변수: 선언하지 않은 변수에 값을 할당

  - 참조할 때 window 생략 가능

  - 전역 변수처럼 사용할 수 있음

  - 예)

    ```javascript
    var x = 1;
    
    y = 2;
    
    function foo() {}
    
    console.log(window.x);
    console.log(x);
    
    console.log(window.y);
    console.log(y);
    
    console.log(window.foo);
    console.log(foo);
    ```

    

let 키워드로 선언한 전역 변수

- 전역 객체의 프로퍼티가 아님
- 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드) 내에 존재



## const 키워드

var 키워드의 단점 보완하기 위해 ES6에서 도입



### 선언과 초기화

값을 변경(재할당)할 수 없으므로 처음 할당한 값을 그대로 유지

상수(constant 변하지 않는 고정된 값)를 변수에 할당하기 위해 사용 (반드시는 아님)

반드시 선언과 동시에 할당이 이루어져야 함

블록 레벨 스코프를 가짐



### 상수

가독성

- 고정된 값으로, 값의 의미를 쉽게 파악

유지보수의 편의

- 프로그램 전체에서 공통 사용하므로 나중에 값이 변경될 경우 상수만 변경하면 됨



상수를 값으로 갖는 변수

- 상수를 저장하고 있음을 명확히 나타냄

- 일반적으로 변수 이름을 대문자로 선언
- 여러 단어로 이루어진 경우, 일반적으로 언더스코어(_)로 구분



### const 키워드와 객체

const 키워드로 선언된 변수

- 변수에 원시 값을 할당한 경우

  - 원시 값은 변경할 수 없는 값이고, const 키워드에 의해 재할당이 금지
  - 할당된 값을 변경할 수 없음

- 변수에 객체를 할당한 경우

  - 재할당이 금지되나, 객체는 변경 가능한 값

  - 할당된 값을 변경할 수 있음

  - 객체의 내용이 변경돼도 변수에 할당된 주소값은 변경되지 않음

  - 예)

    ```javascript
    const person = {
        name: 'Lee'
    };
    
    person.name = 'Kim';
    
    console.log(person);
    ```

    

## var vs. let vs. const

변수 선언 추천

- 기본적으로 const 사용
- let은 재할당이 필요한 경우에 한정해 사용 (변수의 스코프는 최대한 좁게)
- 변경이 발생하지 않는(재할당이 필요 없는) 원시 값과 객체에는 const 사용
- ES6 사용할 경우, var 키워드 사용 x
- 객체는 의외로 재할당을 하는 경우가 드묾