# 전역 변수의 문제점

## 변수의 생명 주기

### 지역 변수의 생명 주기

변수는 자신이 선언된 위치에서 생성되고 소멸

함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸

함수 내부에서 선언된 지역 변수는 함수가 호출되어 실행되는 동안에만 유효

지역 변수의 생명 주기 = 함수의 생명 주기



전역 변수 선언

- 다른 코드가 실행되기 이전에 어디에 있던지 상관없이 가장 먼저 실행

- 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행



지역 변수 선언

1. 함수 호출
   - 변수 선언문이 자바스크립트 엔진에 의해 가장 먼저 실행되어 변수 선언
   - undefined로 초기화

2. 함수 몸체의 문들이 순차적으로 실행
3. 변수 할당문 실행
   - 변수에 값 할당

4. 함수 종료
   - 변수도 소멸
   - 생명 주기 종료



변수 호이스팅

- 스코프를 단위로 동작
- 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작
- 지역 변수는 함수 전체에서 유효 (변수 할당문 실행 이전까지는 undefined 값 가짐)



### 전역 변수의 생명 주기

전역 코드

- 명확한 호출없이 실행
- 전역 코드를 실행하는 특별한 진입점이 없고 코드가 로드되자마자 곧바로 해석되고 실행
- return 문 사용 불가능
- 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료

함수

- 함수 몸체의 마지막 문 또는 return 문 실행되면 종료
- return 문은 함수 몸체 내부에서만 사용 가능 (Node.js 환경에서는 파일의 가장 바깥 영역에 사용해도 에러 발생 x)



var 키워드로 선언한 전역 변수

- 전역 객체의 프로퍼티가 됨
- 브라우저 환경에서 전역 객체는 window
- window는 웹페이지가 종료하기 전까지 유효
- var 키워드로 선언한 전역 변수는 웹페이지를 종료할 때까지 유효



## 전역 변수의 문제점

암묵적 결합

- 전역 변수를 사용하는 의도: 코드 어디에서든지 전역 변수를 사용하겠다!
- 모든 코드가 전역 변수를 참조, 변경할 수 있도록 허용
- 변수의 유효 범위가 클수록 코드의 가독성 나빠지고, 의도치 않게 상태 변경될 수 있는 위험성 높음

긴 생명 주기

- 생명 주기가 길고, 상태를 변경할 기회가 많고, 메모리 리소스를 오랜 기간 소비
- var 키워드는 변수의 중복 선언이 허용되기 때문에 의도치 않은 재할당 가능성

스코프 체인 상에서 종점에 존재

- 변수를 검색할 때 전역 변수가 가장 마지막에 검색됨
- 검색 속도가 가장 느림

네임 스페이스 오염

- 파일이 분리돼 있다해도 하나의 전역 스코프를 공유
- 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 문제



## 전역 변수 사용 억제 방법

### 즉시 실행 함수

함수의 정의와 동시에 호출되는 즉시 단 한번만 호출

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨

전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용

예)

```javascript
(function () {
  var foo = 10;
  // ...
}());

console.log(foo); 
```



### 네임 스페이스 객체

네임 스페이스 역할 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

식별자 충돌 방지 (네임 스페이스를 분리)

네임 스페이스 객체 자체가 전역 변수에 할당 (유용해 보이진 않음)

예)

```javascript
var MYAPP = {};

MYAPP.name = 'Lee';

console.log(MYAPP.name); 
```



네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가해 계층적으로 구성 가능

예)

```javascript
var MYAPP = {};

MYAPP.person = {
  name: 'Lee',
  address: 'Seoul'
};

console.log(MYAPP.person.name); 
```



### 모듈 패턴

관련이 있는 변수, 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만듦

자바스크립트의 클로저 기능을 기반으로 동작

캡슐화 구현 가능

- 캡슐화: 외부에 공개될 필요 없는 정보를 숨기는 것
- 정보 은닉(information hiding)
- 자바스크립트는 public, private, protected 등 접근 제한자 제공하지 않음

전역 네임 스페이스의 오염을 막음

즉시 실행 함수가 객체를 반환하고, 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환

- 퍼블릭 멤버(public member): 반환되는 객체의 프로퍼티는 외부에 노출
- 프라이빗 멤버(private member): 외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근 불가능

예)

```javascript
var Counter = (function () {
  var num = 0;

  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

console.log(Counter.num);

console.log(Counter.increase());
console.log(Counter.increase());
console.log(Counter.decrease()); 
console.log(Counter.decrease()); 
```



### ES6 모듈

2019년 1월 기준, 대부분의 브라우저가 완전히 지원하지 않음

SystemJS, RequireJS 등 모듈 로더 또는 Webpack 등 모듈 번들러 사용해야 함





# let, const와 블록 레벨 스코프

## var 키워드로 선언한 변수의 문제점





## let 키워드

## const 키워드

## var vs. let vs. const