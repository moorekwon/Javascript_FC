# 이벤트

## Introduction

이벤트(event)

- 어떤 사건

- 사용자가 버튼을 클릭했을 때, 웹페이지가 로드되었을 때와 같은 것 (DOM 요소와 관련)

- 발생하는 시점이나 순서를 사전에 인지할 수 없음

- 브라우저가 이벤트를 감지할 수 있으며, 발생 시 통지해 줌 (사용자와 웹페이지 상호작용)

- 일반적으로 함수(이벤트 핸들러)에 연결되고, 그 함수는 이벤트가 발생될 때 실행됨

  ```html
  <!DOCTYPE html>
  <html>
  <body>
    <button class="myButton">Click me!</button>
    <script>
      document.querySelector('.myButton').addEventListener('click', function () {
        alert('Clicked!');
      });
    </script>
  </body>
  </html>
  ```



이벤트 핸들러

- 이벤트가 발생하면 그에 맞는 반응을 함
- 이벤트가 발생하기 전에는 실행되지 않다가 이벤트가 발생되면 실행
- 이벤트에 대응하는 처리를 기술



## 이벤트 루프(Event Loop)와 동시성(Concurrency)

단일 쓰레드

- 브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작

- 쓰레드가 하나뿐
- 하나의 작업(task)만을 처리



자바스크립트 엔진의 영역

- Call Stack(호출 스택)
  - 작업이 요청되면(함수가 호출되면) 요청된 작업이 순차적으로 Call Stack에 쌓이게 되고 순차적으로 실행됨
  - 자바스크립트는 단 하나의 Call Stack을 사용
    - 해당 task가 종료하기 전까지는 다른 어떤 task도 수행될 수 없음 
- Heap
  - 동적으로 생성된 객체 인스턴스가 할당되는 영역



Event Queue(Task Queue)

- 비동기 처리 함수의 콜백 함수, 비동기식 이벤트 핸들러, Timer 함수의 콜백 함수가 보관되는 영역
  - 즉시 실행되지 않고 "tick" 이벤트가 발생하면 태스크 큐로 이동
- 이벤트 루프에 의해 특정 시점에(Call Stack이 비어졌을 때) 순차적으로 Call Stack으로 이동되어 실행됨

Event Loop(이벤트 루프)

- 실제로 동작하는 웹 애플리케이션은 많은 task가 동시에 처리되는 것처럼 느껴짐
- 자바스크립트의 동시성(Concurrency)을 지원
  - 동시성을 지원하기 위해 필요한 비동기 요청(이벤트를 포함) 처리는 자바스크립트 엔진이 아니라 브라우저(또는 Node.js)가 담당

- Call Stack 내에서 현재 실행중인 task가 있는지, Event Queue에 task가 있는지 반복 확인
- Call Stack이 비어있다면 Event Queue 내의 task가 Call Stack으로 이동하고 실행됨

```javascript
function func1() {
  console.log('func1');
  // 함수 func1이 함수 func2를 호출하므로 함수 func2가 Call Stack에 쌓이고 addEventListner가 호출
  func2();
}

function func2() {
  const elem = document.querySelector('.foo');

  // addEventListener의 콜백함수는 foo 버튼이 클릭되어 click 이벤트가 발생하면 태스크 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행
  elem.addEventListener('click', function () {
    this.style.backgroundColor = 'indigo';
    console.log('func2');
  });
  func3();
}

function func3() {
  console.log('func3');
}
// 함수 func1이 호출되면 함수 func1은 Call Stack에 쌓임
func1();
```



## 이벤트의 종류

### UI Event

load: 웹페이지의 로드가 완료됐을 때

unload: 웹페이지가 언로드 될 때 (주로 새 페이지를 요청했을 때)

error: 브라우저가 자바스크립트 오류를 만났을 때, 요청한 자원이 존재하지 않을 때

resize: 브라우저 창의 크기를 조절했을 때

scroll: 사용자가 페이지를 위아래로 스크롤할 때

select: 텍스트를 선택했을 때



### Keyboard Event

keydown: 키를 누르고 있을 때

keyup: 누르고 있던 키를 뗄 때

keypress: 키를 누르고 뗐을 때



### Mouse Event

click: 마우스 버튼을 클릭했을 때

dbclick: 마우스 버튼을 더블 클릭했을 때

mousedown: 마우스 버튼을 누르고 있을 때

mouseup: 누르고 있던 마우스 버튼을 뗄 때

mousemove: 마우스을 움직일 때 (터치스크린에서 동작하지 x)

mouseover: 마우스를 요소 위로 움직였을 때 (터치스크린에서 동작하지 x)

mouseout: 마우스를 요소 밖으로 움직였을 때 (터치스크린에서 동작하지 x)



### Focus Event

focus/focusin: 요소가 포커스를 얻었을 때

blur/focusout: 요소가 포커스를 잃었을 때



### Form Event

input: input 또는 textarea 요소의 값이 변경됐을 때

change: select box, checkbox, radio button의 상태가 변경됐을 때

submit: form을 submit 할 때 (버튼 또는 키)

reset: reset 버튼을 클릭할 때 (최근에는 사용 x)



### Clipboard Event

cut: 콘텐츠를 잘라내기할 때

copy: 콘텐츠를 복사할 때

paste: 콘텐츠를 붙여넣기할 때





## 이벤트 핸들러 등록

이벤트가 발생했을 때 동작할 이벤트 핸들러를 이벤트에 등록



### 인라인 이벤트 핸들러 방식

HTML과 Javascript가 뒤섞이는 문제를 해결할 수 있는 방식

HTML 요소의 이벤트 핸들러 어트리뷰트에 이벤트 핸들러를 등록

더 이상 사용되지 않고 사용해서도 안됨



on으로 시작하는 이벤트 어트리뷰트의 값으로 함수 호출을 전달 (즉시 호출되는 것은 아님)

- 이벤트 어트리뷰트의 키를 이름으로 갖는 함수를 암묵적으로 정의
- 그 함수의 몸체에 이벤트 어트리뷰트의 값으로 전달한 함수 호출을 문으로 가짐

```html
<!DOCTYPE html>
<html>
<body>
  <!-- button 요소의 onclick 프로퍼티에 함수 function onclick(event) { foo(); }가 할당 -->
  <button onclick="myHandler()">Click me</button>
  <script>
    function myHandler() {
      alert('Button clicked!');
    }
  </script>
</body>
</html>
```



이벤트 어트리뷰트의 값은 암묵적으로 정의되는 이벤트 핸들러의 문

- 여러 개의 문을 전달할 수 있음

```html
<!DOCTYPE html>
<html>
<body>
  <button onclick="myHandler1(); myHandler2();">Click me</button>
  <script>
    function myHandler1() {
      alert('myHandler1');
    }
    function myHandler2() {
      alert('myHandler2');
    }
  </script>
</body>
</html>
```



### 이벤트 핸들러 프로퍼티 방식

HTML과 Javascript가 뒤섞이는 문제를 해결할 수 있는 방식

DOM 요소의 이벤트 핸들러 프로퍼티에 (함수 호출이 아닌) 함수를 전달

이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만을 바이딩할 수 있음

```html
<!DOCTYPE html>
<html>
<body>
  <button class="btn">Click me</button>
  <script>
    const btn = document.querySelector('.btn');

    // 실행되지 않음
    btn.onclick = function () {
      alert('Button clicked 1');
    };

    btn.onclick = function () {
      alert('Button clicked 2');
    };
  </script>
</body>
</html>
```



### addEventListener 메소드 방식

addEventListener 메소드를 이용해 대상 DOM 요소에 이벤트를 바인딩하고 해당 이벤트가 발생했을 때 실행될 콜백 함수(이벤트 핸들러)를 지정

대상요소.addEventListener('이벤트', 호출될 함수 [, capture 사용 여부]);

```html
<!DOCTYPE html>
<html>
<body>
  <button class="btn">Click me</button>
  <script>
    const btn = document.querySelector('.btn');

    btn.addEventListener('click', function () {
      alert('Button clicked 1');
    });

    btn.addEventListener('click', function () {
      alert('Button clicked 2');
    });
  </script>
</body>
</html>
```

IE9 이상 (IE 8 이하에서는 attachEvent 메소드를 사용)

```javascript
if (elem.addEventListener) {    // IE 9 ~
  elem.addEventListener('click', func);
} else if (elem.attachEvent) {  // ~ IE 8
  elem.attachEvent('onclick', func);
}
```



addEventListener 함수 방식의 장점

- 하나의 이벤트에 대해 하나 이상의 이벤트 핸들러를 추가할 수 있음
- 캡처링, 버블링 지원
- HTML 요소뿐만 아니라 모든 DOM 요소(HTML, XML, SVG)에 대해 동작
  - 브라우저는 웹 문서(HTML, XML, SVG)를 로드한 후, 파싱해 DOM을 생성



대상 DOM 요소(target)를 지정하지 않으면 전역객체 window, 즉 DOM 문서를 포함한 브라우저의 윈도우에서 발생하는 click 이벤트에 이벤트 핸들러를 바인딩

- 브라우저 윈도우 어디를 클릭해도 이벤트 핸들러가 동작

```html
<!DOCTYPE html>
<html>
<body>
  <label>User name <input type='text'></label>

  <script>
    const input = document.querySelector('input[type=text]');

    // input 요소에서 발생하는 blur 이벤트에 이벤트 핸들러를 바인딩
    input.addEventListener('blur', function () {
      alert('blur event occurred!');
    });
  </script>
</body>
</html>
```



두번째 매개변수는 이벤트가 발생했을 때 호출될 이벤트 핸들러

- 함수 호출이 아니라 함수 자체를 지정

```javascript
// 이벤트 핸들러 함수에 인수를 전달할 수 없음
function foo() {
  alert('blur event occurred!');
}

// input.addEvenetListener('blur', foo());
// -> 이벤트 발생 시까지 대기하지 않고 바로 실행됨
input.addEventListener('blur', foo);  
```

```html
<!-- 위 문제를 우회하는 방법 -->
<!DOCTYPE html>
<html>
<body>
  <label>User name <input type='text'></label>
  <em class="message"></em>

  <script>
    const MIN_USER_NAME_LENGTH = 2;
    const input = document.querySelector('input[type=text]');
    const msg = document.querySelector('.message');

    function checkUserNameLength(n) {
      if (input.value.length < n) {
        msg.innerHTML = '이름은 ' + n + '자 이상이어야 합니다';
      } else {
        msg.innerHTML = '';
      }
    }

    input.addEventListener('blur', function () {
      // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달
      checkUserNameLength(MIN_USER_NAME_LENGTH);
    });
  </script>
</body>
</html>
```



## 이벤트 핸들러 함수 내부의 this

### 인라인 이벤트 핸들러 방식

이벤트 핸들러는 일반 함수로서 호출

- 이벤트 핸들러 내부의 this는 전역 객체 window를 가리킴

```html
<!DOCTYPE html>
<html>
<body>
  <button onclick="foo()">Button</button>
  <script>
    function foo () {
      console.log(this);
    }
  </script>
</body>
</html>
```



### 이벤트 핸들러 프로퍼티 방식

이벤트 핸들러는 메소드

- 이벤트 핸들러 내부의 this는 이벤트에 바인딩된 요소를 가리킴
- 이벤트 객체의 currentTarget 프로퍼티와 같음

```html
<!DOCTYPE html>
<html>
<body>
  <button class="btn">Button</button>
  <script>
    const btn = document.querySelector('.btn');

    btn.onclick = function (e) {
      console.log(this);
      console.log(e.currentTarget);
      console.log(this === e.currentTarget);
    };
  </script>
</body>
</html>
```



### addEventListener 메소드 방식

이벤트 핸들러는 콜백 함수

- 하지만 이벤트 핸들러 내부의 this는 이벤트 리스너에 바인딩된 요소를 가리킴
- 이벤트 객체의 currentTarget 프로퍼티와 같음

```html
<!DOCTYPE html>
<html>
<body>
  <button class="btn">Button</button>
  <script>
    const btn = document.querySelector('.btn');

    btn.addEventListener('click', function (e) {
      console.log(this);
      console.log(e.currentTarget);
      console.log(this === e.currentTarget);
    });
  </script>
</body>
</html>
```



## 이벤트의 흐름





## Event 객체

## Event Delegation (이벤트 위임)

## 기본 동작의 변경

