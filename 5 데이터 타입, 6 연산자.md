# 데이터 타입

## 데이터 타입이란 무엇인가? 왜 필요한가?

데이터 타입 = 값의 종류



### 데이터 타입에 의한 메모리 공간의 확보

메모리에 값 저장 -> 먼저 확보해야 할 메모리 공간의 크기 알기

데이터 타입에 따라 필요한 메모리의 크기 다름



### 데이터 타입에 의한 값의 해석

메모리 셀의 개수(byte 수) = 컴퓨터가 한번에 읽어 들여야 할 메모리 공간의 크기



모든 값이 데이터 타입을 가져야 하는 이유

- 값 저장할 때 확보해야 할 메모리 공간의 크기 결정
- 값 참조할 때 한번에 읽어 들여야할 메모리 공간의 크기 결정
- 메모리에서 읽어 들인 2진수 어떻게 해석할 지 결정



## 값

값(value) = 더 이상 평가할 수 없는 하나의 표현식

변수(Variable) = 하나 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체

=> 값을 변수에 할당



## 값의 생성

### 리터럴

소스 코드 안에서 직접 만들어 낸 고정된 값 자체

리터럴 표기법으로 생성



#### 리터럴 표기법을 통한 값의 생성

사람이 이해할 수 있는 표기법으로 값의 생성을 자바스크립트 엔진에게 명령

자바스크립트 엔진에 의해 값으로 평가

런타임(코드가 실행되는 시점)에 리터럴 해석, 리터럴에 상응하는 값 생성



#### 값과 리터럴의 관계

리터럴 = 값 (리터럴 자체로 값이 될 수 있다는 의미)



### 표현식

값을 생성하는 문(방법)

리터럴, 식별자, 연산자, 함수, 호출 등의 조합

하나의 값으로 평가될 수 있는 문



평가: 표현식을 해석해 하나의 값을 만드는 과정



## 데이터 타입의 분류

자바스크립트(ES6) 7개의 데이터 타입 제공

1. 원시 타입(primitive type)
   - 숫자(number) 타입: 정수, 실수 -> 주로 산술 연산
   - 문자열(string) 타입 -> 주로 텍스트 화면에 출력
   - 불리언(boolean) 타입: 참(true), 거짓(false)
   - undefined 타입: 선언은 됐지만 값 할당하지 않은 변수에 할당
   - null 타입: 값이 없다는 것을 명시
   - Symbol 타입: ES6에서 새롭게 추가
2. 객체 타입(object/reference type
   - 객체
   - 함수
   - 배열



## 숫자 타입

하나의 숫자 타입만 존재

배정밀도 64비트 부동소수점 형식의 2진수로 저장

=> 모든 수를 실수로 처리 (integer type 따로 존재하지 x)



> 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.



특별한 값 표현

- Infinity: 양의 무한대 예) 10 / 0

- -Infinity: 음의 무한대 예) 10 / -1

- NaN: 산술 연산 불가 예) 1 * 'String'

  

## 문자열 타입

텍스트 데이터 표현

0개 이상의 16bit 유니코드 문자(UTF-16)들의 집합

생성: '', "", ``

원시 타입. 변경 불가능(immutable value)



### 템플릿 리터럴

- ES6부터 새로 도입

- ` 사용
- 줄바꿈 허용되지 않음
- 이스케이프 시퀀스 사용(\로 시작하여 공백 표현)
- 여러 줄에 걸쳐 작성 가능
- 공백 있는 그대로 적용



문자열 인터폴레이션(String Interpolation)

- '+' 사용하지 않고 간단하게 새로운 문자열 삽입

+ ${expression}



## 불리언 타입

논리적 참, 거짓을 나타내는 true, false



## undefined 타입

선언은 되었지만 값을 할당하지 않은 변수에 undefined로 초기화

변수 선언 -> 메모리 공간 확보 -> 처음 할당 이루어질 때까지 빈 상태 -> 내버려두지 않고 undefined



선언: 식별자 생성되었지만 값이 아직 할당되지 않은 상태

정의: 식별자 생성되었고 값도 할당되어 있는 상태



## null 타입

변수에 값이 없다는 것을 의도적으로 명시(의도적 부재)

변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미

자바스크립트 엔진은 메모리 공간에 대해 가비지 콜렉션 수행



함수가 유효한 값 반환할 수 없는 경우 명시적으로 할당



## symbol 타입

변경 불가능한 원시 타입의 값

이름 충돌의 위험이 없는 객체의 유일한 프로퍼티 키로 사용

Symbol 함수를 호출해 유일한 심볼 값 생성 



> 심볼은 Symbol 함수를 호출해 생성한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다.



## 객체 타입

자바스크립트는 객체 기반의 언어

자바스크립트를 이루고 있는 거의 모든 것이 객체



## 동적 타이핑

### 동적 타입 언어와 정적 타입 언어

정적 타입 언어

- C, Java, 등

- 데이터 타입 사전에 선언(명시적 타입 선언)
- 변수에 선언한 타입에 맞는 값만 할당
- 컴파일 시점에 타입 체크 수행 -> 통과 못했으면 에러 발생, 프로그램 실행 중지
- 변수 선언 시점에 변수의 타입 결정. 변경 불가능

동적 타입 언어

- 자바스크립트, Python, 등

- 변수 선언할 때 타입 선언하지 x(var, let, const 키워드 사용)
- 어떠한 데이터 타입의 값이라도 자유롭게 할당
- 동적 타이핑: 값 할당 시점에 변수의 타입 동적으로 결정. 변경 가능(재할당)



동적 타이핑: 값 할당에 의해 변수 타입 결정되고, 재할당에 의해 언제든지 동적으로 타입 변경 가능



### 동적 타입 언어와 변수

동적 타입 언어의 위험

- 자바스크립트 엔진에 의한 암묵적인 타입 자동 변환으로 값의 타입 확신 어려움
- 유연할수록 신뢰성 떨어짐
- 변수 사용하기 전 데이터 타입 체크해야 하는 번거로움, 코드량 증가, 버그 발생 확률과 테스트 분량 증가





# 연산자

## 표현식과 연산자

표현식: 하나의 값으로 평가될 수 있는 문

=> 결국 하나의 값이므로, (표현식이 평가되어 생성된) 값과 동등한 관계(동치)

=> 값이 위치하는 자리에 표현식도 위치 가능



## 문과 표현식

자바스크립트의 모든 코드는 문 또는 표현식



문

- 마침표로 끝나는 하나의 완전한 문장
- var, let, const, function, class 등 선언 키워드 사용해 변수, 함수, 클래스 생성 가능
- if, for, while문 등 제어문 생성해 프로그램 흐름 제어 가능

표현식

- 문을 구성하는 구

- 값 생성 이상의 행위 불가

  

=> 문은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령

=> 프로그램은 문의 집합으로 이루어진 것

=> 프로그래밍은 문을 작성하고 순서에 맞게 나열하는 것



## 표현식인 문과 표현식이 아닌 문

표현식인 문

- 값으로 평가될 수 있는 문
- 변수에 할당 가능
- undefined 반환

표현식이 아닌 문

- 값으로 평가될 수 없는 문
- 변수에 할당하면 에러 발생
- 평가된 값 반환



## 연산자란?

연산자(Operator): 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산 수행해 하나의 값 생성



피연산자(Operand): 연산의 대상(값)



## 산술 연산자

피연산자 대상으로 수학적 계산 수행해 새로운 숫자 값 생성

산술 연산 불가능 -> NaN 반환



### 이항 산술 연산자

- 2개의 피연산자를 산술 연산

- 부수 효과 x

- +(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(나머지)



### 단항 산술 연산자

- 1개의 피연산자를 산술 연산
- ++(증가), --(감소), +(아무 효과 x), -(양수를 음수로, 음수를 양수로)
- ++(증가), --(감소) -> 부수 효과 o (피연산자의 값 변경)
  - 선할당 후증가 / 선증가 후할당 / 선할당 후감소 / 선감소 후할당



### 문자열 연결 연산자

'+' 연산자: 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작



암묵적 타입 변환(타입 강제 변환): 숫자 타입으로 강제 변환 후 연산 수행



## 할당 연산자

- 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당

- 부수 효과 o
- =, +=, -=, *=, /=, %=



## 비교 연산자

- 좌항과 우항의 피연산자 비교한 후 그 결과를 불리언 값으로 반환

- if문, for문 등 제어문의 조건식에서 주로 사용



### 동등 / 일치 비교 연산자

- 부수 효과 x

- ==: 동등 비교(값이 같음)
- ===: 일치 비교(타입이 같음)
- !=: 부동등 비교(값이 다름)
- !==: 불일치 비교(타입이 다름)



### 대소 관계 비교 연산자

- 부수 효과 x
- '>', '<', '>=', '<='



## 삼항 조건 연산자

- 조건식의 평가 결과에 따라 반환할 값 결정 (표현식인 문)

- 부수 효과 x
- 표현식: 조건식 ? 조건식이 true일때 반환 값 : 조건식이 false일때 반환 값
- 예: x % 2 ? '홀수' : '짝수'



## 논리 연산자

- 부수 효과 x
- ||(OR), &&(AND), !(NOT)



## 쉼표 연산자

마지막 피연산자의 평가 결과 반환

예)

```javascript
var x, y, z;

x = 1, y = 2, z = 3
```

=> 결과값: 3



## 그룹 연산자

연산자의 우선 순위 조절

예)

10 * (2 + 3)

=> 결과값: 50



## typeof 연산자

7가지 문자열 중 하나 반환

- string, number, boolean, undefined, symbol, object, function
- null 반환 x
- 함수 -> function
- 선언하지 않은 식별자 -> undefined (ReferenceError 발생하지 x)



## 지수 연산자

- ES7에서 새롭게 도입
- 형태: 밑 ** 지수
- 모든 이항 연산자보다 우선 순위 높음